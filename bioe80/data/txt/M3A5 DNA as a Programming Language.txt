We're going to explore the idea that DNA could be developed as a programming language. We mean this in an engineering context as opposed to what exists already in nature. Could we develop a language for programming DNA? Let's stop for a minute and think about what languages are. We take it for granted. Like, oh, we're speaking, we're using a language. More abstractly, we can think of languages as systems for representing things we see, our wishes and intentions, ideas, and more. Languages themselves are a type of technology for representation and communication. For example, if we go back to the 19th century and to Cork, Ireland, we can see the work of George Boole, very curiously titled publication, The Laws of Thought, an investigation of the laws of thought, and then of which are founded the mathematical theory of logic and probability. So here's Mr. Boole as represented in the 1850s. Let's just take a little snippet of the text we can find in this book. The link to the reference is at the bottom. I encourage you to explore it. Signs of mental operations whereby we collect parts into a whole or separate a whole into its parts. Now, remember, he's thinking about thought and the laws of thought. We are not only capable of entertaining the conceptions of objects as characterized by names, qualities, or circumstances applicable to each individual of the group under consideration, but also of forming the aggregate conception of a group of objects consisting of partial groups, each of which is separately named or described. Okay, that's pretty abstract. Let's see. Okay, good examples. We use the conjunctions and, or, etc. For example, trees and minerals, barren mountains or fertile veils are examples of this kind. In the strictness, the word and or interposed between the terms descriptive of two or more classes of objects imply that those classes are distinct so that no member of one is found in another because you don't find a fertile veil in a barren mountain and vice versa. Okay, and this in all other respects, the word and or are analogous with the sign plus addition in algebra. One thing you should notice is this is really formal thought in and of itself, but hidden within it and explained is the idea that words are being developed because they're useful, they have utility. The word and is incredibly useful because it allows us to represent something about what we observe. You know, if it's warm and sunny, then I might go to the beach. And of course, Boole is famous for Boolean logic, which allows us to do operations both via language and computers, whether electrical, mechanical, or biological. So again, this is pretty esoteric, but if you go back into the formal development of languages, you can learn a lot firstly, but also you can imagine languages as these more abstract things such that, you know, we might be having class in English, or you might be communicating with a computer in Python or some other computer programming language. And I should be careful, an electrical computer programming language, as opposed to a biological computer, or maybe we could have one or more languages for programming and DNA. What are those languages going to be called? I don't know, like maybe it's your name language, right? You might be able to be the person who makes that language. So that's hopefully gives you a sense of what we're talking about. I want to share and introduce you quickly to a hero of mine. This is Professor Vassie Ware from Lehigh University in Bethlehem, Pennsylvania. Professor Ware was my professor, gosh, probably around 1992 when I was a student studying genetics. So she was my genetics professor. And I would think I was the only engineer in the class. We met really early. We met like 7.45 in the morning, but she would always bring bagels or donuts and a lot of orange juice. And I would sit there confused mostly because I didn't understand genetics, but she was such a great teacher. And I want to relate to you what it was like to be a student in that class. One of the things that would happen is she would show us pictures, structures of molecules. And we've already been looking at these. And I would sit in the back of the class and I'm going, what's up with this? Like, why do I need to understand the structure of this molecule? So let's just use this one as an example. What's it do? What does it do? Can you figure it out just by looking at it? And of course, there's the link down in the bottom left. If you want to go to the protein data bank and learn more about it and turn it around in a web browser, I encourage you to do that. But for now, tell me what you see here. I guess I see some orange glob and a blue glob. Those must be proteins. And this is interesting. It looks like a double helix becoming, maybe this is a double helix of DNA. And then a single strand of DNA. The DNA seems to be going through these globs. So it's like a DNA going through a protein pore. And I see a minus and a plus. That reminds me of electronics. This turns out to be a protein that can be used to sequence DNA by passing the DNA through a pore and looking at changes of current as different bases of DNA go through the pore. This is the basis of what's called nanopore sequencing, which we'll learn about later. But what's this got to do with language? As a student, I didn't want to understand how this thing worked. I just wanted Professor Ware to tell me what it did. Don't give me all this complexity of how the things work. Just tell me what it does. Let's try another example. Hey, what's this? Looks interesting. It looks kind of crazy. It's got, I don't know, what is this thing? Just tell me what it does. I don't know. Do I need to know the etymology of a word to use the word and all the details? No, I just want to know what the word is so I can use it. This is me thinking like an engineer in a somewhat naive way. Oh, OK. It's the photosynthetic super complex. Kind of important. Takes in sunlight, fixes carbon dioxide, makes sugar. All right. How about this? What's this? Of course, they're beautiful things to look at and imagine. I just want to know. I just want to use it for something. I just want to be an engineer. Oh, it's a cellulose synthase. Mix wood. What's this? I have no idea. Oh, of course. It's biodegradable plastic. You see what's happening? As soon as I know what it is, as soon as you tell me what it is, I'm excited. It's not that other people can't get excited about the structure and all the details. It's like, I just want to biodegrade plastic. How about this? What's this? SARS-2 spike protein and antibodies. All right. For preventing an infection. What's this? I see that gray box. Maybe it's another membrane thing. But I have no idea. Caspasin, a receptor for the spicy stuff. Whoa. How would I know that? Just by looking. What's this? I guess it's the same thing looking top down and on the side and the bottom. Yeah. Voltage-gated sodium channel. I could use a change in voltage to let ions go through a membrane. That'll be interesting for nerves, neurons, other things maybe. What are these things? Fold it one, fold it three. Fairy dog diesel. Citizen science designer proteins. I don't know what they do, but that's cool. Somebody made them. Citizen science. Let's zoom out and make sense of this. I could go on forever going through the entire PDB with all the structures and all the functions and just be like, hmm. But the point here around language is, could we ever organize these relationships between the functional objects themselves, the biomolecules, and their abstracted representation? Representation is such a cool word. Slow it down. Re-presentation. Re-present. So could we ever organize these relationships between the functional objects, the biomolecules, and these names, these abstracted representations like cellulose synthase, along with a grammar, rules for composing these objects into more complicated systems? If we can do that, then we might be able to develop languages for programming life. You want to think about this with pictures, with English as a language, or any human-to-human language. We're familiar with dictionaries as definitions of words. This is the relationship between the name of the word and its function. And of course, we have the rules of grammar, which give us the instructions for how to compose words reliably to make sentences and paragraphs and novels and so on. Could we develop this type of capacity, this bioengineering infrastructure, such that we could have one or more languages for relating to living systems, for expressing our wishes and intentions within the code of life? For example, wouldn't it be nice if I could say, you know, I'd like a cell that floats when it's sunny. And that's all I needed to do. And by saying that, a whole bunch of grammar and functions would compose into a low-level DNA sequence that could be made, and then we'd have a cell that floats when it's sunny. That's what it's like to have a language. We have functions and definitions and grammar we can compose, and we get what we want. Of course, you've got to be creative and do the editing and learn how to use the grammar and understand the definitions. But essentially, this is what we're going for. What might this look like? Well, I'm going to need a sunlight detector as a device, and I'm going to need a buoyancy modulator, something to control floating or sinking. And if I could just get those off the shelf, and then I could get the DNA sequences encoding those things, and I could then we'd have a cell that floats when it's sunny. And I wouldn't necessarily have to be an expert in sunlight detection, right? Somebody would have figured that out before and created the entry in the dictionary. Sure enough, students before you have been working on this more than anybody else, frankly, because they want it. They want this language and grammar. Here's an example. The Registry of Standard Biological Parts, made by students in high school and college. The website is down at the bottom where you just go to the website, college. The website is down at the bottom where you just go to parts.igem.org. Here's a part we can find in this very immature early dictionary for programming DNA. Part number I750016. I guess a computer could like that name. Here's a better name. Gas Vesicle Polycistronic Gene. This part contains 11 open reading frames or genes encoding proteins from a bacteria, Bacillus megaterium. If you express this, you make gas vesicles, tiny little protein balloons in cytoplasm that are maybe 60 nanometers across. Or if the cell was as big as the building, 100 meters, that's maybe a two meter balloon. And these organelles contain gas and therefore can control the buoyancy of the cell. To read more, check out this reference. But you can just read as much as you want on this website. Okay. And look, on this website, there's a little link. It says get part sequence. We can click that link. Now we've got the DNA sequence encoding the genes that make a tiny little protein balloon in the cytoplasm of bacteria. This is the protein balloon generator DNA. In other words, a transcription source, the reading out of this DNA can be used to modulate buoyancy. And it starts with an A, A, A, G, G, G. I don't know what's going on there. It's like, there's about 6,000 letters it looks like. You have to be an expert in this to understand what all the letters do. And that's okay. Maybe that's what you want to do. That's cool. Then I would need, what else? I need a sunlight detector. And earlier in the class, we were talking about, what was it? The edge detector based on collecting light patterns and then determining where the boundaries in those patterns are. Here's earlier work leading to that by Jeff Tabor, Chris Voigt, Andy Ellington, and some Laskaia and colleagues. The simpler version is here, just take the bacterial picture, right? So there's a portrait of Andy Ellington, second from the right. And I think that's the flying spaghetti monster captured in a bacterial plate. It's not a Polaroid image. They call it a coliroid for E. coli. Okay. So I've got a light sensor here. I could find that sequence. And if I put those two together and compose those pieces of DNA and then got that DNA into a bacterium, then I'd have a cell that floats when it's sunny. So that should give you an idea of if we could organize the functions of life, create a grammar, supporting composition, you'd be able to have a programming language for DNA. Let me give you another example and a sense of the formalism that underlies this type of work. And I want to be really careful. In the year 2023, this type of bioengineering idea is about 20 years old and people have been working on it sputteringly for the last couple of decades. But you cannot now go to the perfectly reliable dictionary of biological functions. You cannot now go and read the perfectly reliable grammar for composing. We're getting there, but it's such a fundamental topic that the work is ongoing and will fill in over the next decade or two completely. Let's say, for example, I wanted to make an eight-bit counter. What the heck's that? Well, one bit, zero, one. Now I have eight bits. So eight zeros and ones. And let's imagine I make this counter. Each bit is just controlled or represented by taking a piece of DNA I engineer and I can flip the DNA. So it's like the DNA is pointing to the right. That's a zero. Or if it's pointing to the left, that's a one. And just by flipping a little string of DNA back and forth, I go zero, one, zero, one, zero, one. And then if I have eight of these things, like zero, one, flip, flip, now I can count to four if I just keep adding. So that's what this little image looks like. Give me an eight-bit counter because then I could count to two to the eighth, which is 256. I could count anything I could count. I could count how many times a cell is divided. How old is the cell? How many times arsenic pollution signal has been coming in and exposing the cell of that pollutant? I just want to keep track of things. This looks like, how am I going to make this thing? It's going to be pretty complicated. What's the DNA sequence encoding a genetic eight-bit counter? If we tried to go right from this little schematic to those details, we'd be up all night and for a whole century probably up all night. So instead, what we're going to try and do is rely on the idea that we could have a formalized device framework and says, you know, I just need flippers. And, you know, the person making the eight-bit counter could just ask the flipper engineer, like, hey, I need eight flippers. And the flipper bioengineer go, here you go. Right. And now the person working on the system, this eight-bit counter or any other system, you know, would compose those devices and they'd be happy. Just like we were doing before. I want a sunlight detector and a buoyancy generator. Hey, give me those things. And, you know, the grammar and the dictionary would exist. And somebody would give you those things and you'd be on your way with your, you know, cell that's floating when it's sunny. So that's the idea here. Now, who's going to make the flippers and what are those going to be made of? They're going to be made of biological molecules, the parts themselves. And so the device engineers who are making these abstracted functions are going to have to call it, hello, anybody got some parts for flipping DNA, recombinases or integrases? Suddenly I'm using a lot of bio jargon because the details are going to matter. But if the folks who understand that are organized and well-instructed in terms of how to compose those functions to give them to device engineers, to bundle them up into simpler representations that do the functions, then you could give them to the people making the systems and be like, we'd have a language, right? You know, just like if I wanted to send my mom a text message or something like that on the phone, I'd be calling on some functions with my fingers. Inside this machine, there's all sorts of zeros and ones rolling. I have no idea how that works. I just know what's happening. But I get to call on these high level functions that are letting me program this computing object. Ultimately in biology, we've got to encode these parts. We've got to compose it into the DNA sequence itself. That's the genetic material, right? So this is what's called an abstraction hierarchy or a framework that lets you systematically organize layers of function. And as you compile down, you get closer and closer to the instantiation of it in actual living matter, in our case, in DNA. And you could replace what's on the top. Again, we had the example of a cell that floats when it's sunny. There could be an example of like a super spirulina smoothie organism that's making extra vitamins when it's rainy, right? Or whatever you like, right? It's like, what are the number of poems you could come up with? You have a language and grammar. It's an infinite number of poems. What are the number of computer programs you could write? It's an infinite number, right? So we're creating a framework for supporting open-ended generative construction and composition. There's a lot to learn here. And so this is just meant to be an introduction. I want to point you to a comic book. You can find the free PDF download online at the link at the bottom. And if you wanted to learn more about it, which we would encourage you to, take a look at this comic. It's available in six or seven different languages. And of course, in this week's PISA, you'll have some opportunities to practice this sort of thinking around abstracting genetic functions. So to end for now, let's offer a few questions to reflect upon. Slow down and just go back. What are languages? Human languages? Computer languages? Bio languages? What are languages? What must be true for any language to work well? In bioengineering, what do you think the biggest challenges are going to be in terms of getting to one or more languages within living systems? Is it going to be making the dictionary? Is it going to be coming up with the grammar? Is it going to be something else? How long until this is all work in progress? How long until you think anyone can learn how to program DNA? How long until we've got the equivalent of the grammar books and the dictionary for life and it works reliably? You just have to learn the language, but the language works. How much work do you think that's going to be? Do you think it's like five years, 500 years? Maybe you think it's impossible. Maybe it'll never happen. OK, that's it.